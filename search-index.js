var searchIndex = {};
searchIndex["pmemblk_sys"] = {"doc":"# FFI bindings to **libpmemblk**","items":[[4,"PMEMblkpool","pmemblk_sys","",null,null],[5,"pmemblk_open","","",null,null],[5,"pmemblk_create","","",null,null],[5,"pmemblk_close","","",null,null],[5,"pmemblk_bsize","","",null,null],[5,"pmemblk_nblock","","",null,null],[5,"pmemblk_read","","",null,null],[5,"pmemblk_write","","",null,null],[5,"pmemblk_set_zero","","",null,null],[5,"pmemblk_set_error","","",null,null],[5,"pmemblk_check_version","","",null,null],[5,"pmemblk_check","","",null,null],[5,"pmemblk_errormsg","","",null,null],[7,"PMEMBLK_MIN_POOL","","",null,null]],"paths":[]};
searchIndex["pmemlog_sys"] = {"doc":"# FFI bindings to **libpmemlog**","items":[[4,"PMEMlogpool","pmemlog_sys","",null,null],[5,"pmemlog_open","","",null,null],[5,"pmemlog_create","","",null,null],[5,"pmemlog_close","","",null,null],[5,"pmemlog_nbyte","","",null,null],[5,"pmemlog_append","","",null,null],[5,"pmemlog_appendv","","",null,null],[5,"pmemlog_tell","","",null,null],[5,"pmemlog_rewind","","",null,null],[5,"pmemlog_walk","","",null,null]],"paths":[]};
searchIndex["pmemobj_sys"] = {"doc":"# FFI bindings to **libpmemobj**","items":[[4,"PMEMobjpool","pmemobj_sys","",null,null],[5,"pmemobj_open","","",null,null],[5,"pmemobj_create","","",null,null],[5,"pmemobj_close","","",null,null],[5,"pmemobj_memcpy_persist","","",null,null],[5,"pmemobj_memset_persist","","",null,null],[5,"pmemobj_persist","","",null,null],[5,"pmemobj_flush","","",null,null],[5,"pmemobj_drain","","",null,null],[5,"pmemobj_errormsg","","",null,null]],"paths":[]};
searchIndex["pmem_sys"] = {"doc":"# FFI bindings to **libpmem**","items":[[5,"pmem_is_pmem","pmem_sys","",null,null],[5,"pmem_persist","","",null,null],[5,"pmem_msync","","",null,null],[5,"pmem_map_file","","",null,null],[5,"pmem_unmap","","",null,null],[5,"pmem_flush","","",null,null],[5,"pmem_drain","","",null,null],[5,"pmem_has_hw_drain","","",null,null],[5,"pmem_memmove_persist","","",null,null],[5,"pmem_memcpy_persist","","",null,null],[5,"pmem_memset_persist","","",null,null],[5,"pmem_memmove_nodrain","","",null,null],[5,"pmem_memcpy_nodrain","","",null,null],[5,"pmem_memset_nodrain","","",null,null],[5,"pmem_check_version","","",null,null],[5,"pmem_errormsg","","",null,null]],"paths":[]};
searchIndex["pmem_blk"] = {"doc":"Arrays of pmem-resident blocks, all the same size, that are atomically updated.\nFor example, a program keeping a cache of fixed-size objects in pmem might find this library useful.","items":[[5,"check_version","pmem_blk","Checks the version of the **libpmemblk** library",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"result"}}],[0,"blkpool","","",null,null],[7,"MIN_POOLSIZE","pmem_blk::blkpool","",null,null],[3,"BlkPool","","",null,null],[11,"open_no_size","","Opens an existent memory pool with an _unknown_ block size",0,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"open","","Opens an existent memory pool",0,{"inputs":[{"name":"p"},{"name":"usize"}],"output":{"name":"result"}}],[11,"create","","Creates a block memory pool with the given total `poolsize` divided up into as many elements of size `blksize` as will fit in the pool",0,{"inputs":[{"name":"p"},{"name":"usize"},{"name":"usize"}],"output":{"name":"result"}}],[11,"block_size","","The block size for this pool",0,null],[11,"capacity","","The capacity of the pool in number of blocks",0,null],[11,"read","","Reads block number `blockno` from the memory pool into `buf`",0,null],[11,"write","","Writes a block from `buf` to block number `blockno` in the memory pool",0,null],[11,"check","","Check consistency of the memory pool",0,{"inputs":[{"name":"p"},{"name":"usize"}],"output":{"name":"result"}}],[11,"drop","","",0,null]],"paths":[[3,"BlkPool"]]};
searchIndex["pmem_log"] = {"doc":"A pmem-resident log file.\nThis is useful for programs like databases that append frequently to a log file.","items":[[0,"log","pmem_log","",null,null],[3,"Log","pmem_log::log","",null,null],[11,"open","","",0,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"create","","",0,{"inputs":[{"name":"p"},{"name":"usize"}],"output":{"name":"result"}}],[11,"append","","",0,null],[11,"append_many","","",0,null],[11,"len","","",0,null],[11,"capacity","","",0,null],[11,"walk","","",0,null],[11,"drop","","",0,null]],"paths":[[3,"Log"]]};
searchIndex["pmem_obj"] = {"doc":"Transactional object store, providing memory allocation,\ntransactions, and general facilities for persistent memory programming.","items":[[0,"objpool","pmem_obj","",null,null],[3,"ObjPool","pmem_obj::objpool","",null,null],[11,"open","","",0,{"inputs":[{"name":"p"},{"name":"s"}],"output":{"name":"result"}}],[11,"create","","",0,{"inputs":[{"name":"p"},{"name":"s"},{"name":"usize"}],"output":{"name":"result"}}],[11,"drop","","",0,null]],"paths":[[3,"ObjPool"]]};
searchIndex["pmem"] = {"doc":"# FFI bindings to **libpmem**","items":[[5,"errormsg","pmem","Description of the last error",null,{"inputs":[],"output":{"name":"option"}}],[5,"is_pmem","","Checks if an entire object consists of persistent memory\nIf `true` then it is safe to use `persist(1)` and other related functions to make changes durable for that memory range.",null,{"inputs":[{"name":"t"}],"output":{"name":"bool"}}],[5,"persist","","Force an object to be stored durably in persistent memory.",null,{"inputs":[{"name":"t"}],"output":null}],[5,"msync","","Forces any changes in an object to be stored durably.",null,{"inputs":[{"name":"t"}],"output":{"name":"result"}}],[5,"msync_unsized","","",null,{"inputs":[{"name":"t"}],"output":{"name":"result"}}],[5,"flush","","Flushes the processor caches",null,{"inputs":[{"name":"t"}],"output":null}],[5,"drain","","Waits for any pmem stores to drain from HW buffers",null,{"inputs":[],"output":null}],[5,"has_hw_drain","","Wether or not the machine supports an explicit hardware drain instruction for persistent memory.",null,{"inputs":[],"output":{"name":"bool"}}],[5,"check_version","","Checks the version of the **libpmem** library",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"result"}}],[0,"pmap","","Persistent memory maps",null,null],[3,"PersistentMap","pmem::pmap","Persistent memory region",null,null],[11,"create","","",0,{"inputs":[{"name":"p"},{"name":"usize"},{"name":"bool"},{"name":"u16"}],"output":{"name":"result"}}],[11,"create_tmp","","",0,{"inputs":[{"name":"d"},{"name":"usize"},{"name":"bool"},{"name":"u16"}],"output":{"name":"result"}}],[11,"open","","",0,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"open_or_create","","",0,{"inputs":[{"name":"p"},{"name":"usize"},{"name":"bool"},{"name":"u16"}],"output":{"name":"result"}}],[11,"is_pmem","","",0,null],[11,"len","","",0,null],[11,"uninitialized","","",0,null],[11,"zeroed","","",0,null],[11,"write","","",0,null],[11,"read","","",0,null],[11,"as_ptr","","",0,null],[11,"as_mut_ptr","","",0,null],[11,"as_pmem_ptr","","",0,null],[11,"as_pmem_mut_ptr","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"drop","","",0,null],[0,"ptr","pmem","The functions in this section provide optimized copying to persistent memory",null,null],[3,"PmemConstVirtualPtr","pmem::ptr","Persistent memory virtual pointer",null,null],[3,"PmemMutVirtualPtr","","Persistent memory virtual mutable pointer",null,null],[3,"PmemConstPtr","","Direct `*const T` pointer to a pmem location",null,null],[3,"PmemMutPtr","","Direct `*mut T` pointer to a pmem location",null,null],[5,"null","","",null,{"inputs":[],"output":{"name":"pmemconstvirtualptr"}}],[5,"null_mut","","",null,{"inputs":[],"output":{"name":"pmemmutvirtualptr"}}],[5,"copy","","Copies `count * size_of&lt;T&gt;` bytes from `src` to `pmemdest`. The source and destination may overlap.",null,null],[5,"copy_nonoverlapping","","Copies `count * size_of&lt;T&gt;` bytes from `src` to `pmemdest`. The source and destination may _not_ overlap.",null,null],[5,"write_bytes","","Invokes memset on the specified pointer, setting `count * size_of::&lt;T&gt;()` bytes of memory starting at `pmemdest` to `val`.",null,null],[5,"write","","Overwrites a memory location with the given value without reading or dropping the old value.",null,null],[5,"msync","","",null,null],[11,"clone","","",1,null],[11,"new","","",1,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"self"}}],[11,"is_null","","",1,null],[11,"as_type","","",1,null],[11,"as_mut","","",1,null],[11,"null","","",1,{"inputs":[],"output":{"name":"self"}}],[11,"offset","","",1,null],[11,"link","","",1,null],[11,"fmt","","",1,null],[11,"fmt","","",1,null],[11,"default","","",1,{"inputs":[],"output":{"name":"self"}}],[11,"clone","","",2,null],[11,"new","","",2,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"self"}}],[11,"is_null","","",2,null],[11,"as_type","","",2,null],[11,"as_const","","",2,null],[11,"fmt","","",2,null],[11,"fmt","","",2,null],[11,"null","","",2,{"inputs":[],"output":{"name":"self"}}],[11,"offset","","",2,null],[11,"link","","",2,null],[11,"default","","",2,{"inputs":[],"output":{"name":"self"}}],[11,"clone","","",3,null],[11,"is_null","","",3,null],[11,"as_mut","","",3,null],[11,"null","","",3,{"inputs":[],"output":{"name":"self"}}],[11,"direct","","",3,null],[11,"as_virtual","","",3,null],[11,"offset","","",3,null],[11,"as_type","","",3,null],[11,"fmt","","",3,null],[11,"fmt","","",3,null],[11,"default","","",3,{"inputs":[],"output":{"name":"self"}}],[11,"clone","","",4,null],[11,"is_null","","",4,null],[11,"as_const","","",4,null],[11,"null","","",4,{"inputs":[],"output":{"name":"self"}}],[11,"direct","","",4,null],[11,"as_virtual","","",4,null],[11,"offset","","",4,null],[11,"as_type","","",4,null],[11,"fmt","","",4,null],[11,"fmt","","",4,null],[11,"default","","",4,{"inputs":[],"output":{"name":"self"}}],[0,"cell","pmem","",null,null],[3,"PmemRef","pmem::cell","",null,null],[3,"PmemMutRef","","",null,null],[11,"new","","",5,null],[11,"deref","","",5,null],[11,"fmt","","",5,null],[11,"fmt","","",5,null],[11,"new","","",6,null],[11,"deref","","",6,null],[11,"deref_mut","","",6,null],[11,"fmt","","",6,null],[11,"fmt","","",6,null],[0,"nodrain","pmem","The functions in this section provide optimized copying to persistent memory _without_ draining",null,null],[5,"copy","pmem::nodrain","Copies `count * size_of&lt;T&gt;` bytes from `src` to `pmemdest`. The source and destination may overlap.",null,null],[5,"copy_nonoverlapping","","Copies `count * size_of&lt;T&gt;` bytes from `src` to `pmemdest`. The source and destination may _not_ overlap.",null,null],[5,"write_bytes","","Invokes memset on the specified pointer, setting `count * size_of::&lt;T&gt;()` bytes of memory starting at `pmemdest` to `val`.",null,null]],"paths":[[3,"PersistentMap"],[3,"PmemConstVirtualPtr"],[3,"PmemMutVirtualPtr"],[3,"PmemConstPtr"],[3,"PmemMutPtr"],[3,"PmemRef"],[3,"PmemMutRef"]]};
initSearch(searchIndex);
